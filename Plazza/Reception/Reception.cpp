///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include "Reception/Reception.hpp"
#include "iostream"
#include "IPC/Message.hpp"
#include "IPC/Pipe.hpp"

///////////////////////////////////////////////////////////////////////////////
// Namespace Plazza
///////////////////////////////////////////////////////////////////////////////
namespace Plazza
{

///////////////////////////////////////////////////////////////////////////////
Reception::Reception(std::chrono::milliseconds restockTime, size_t CookCount)
    : m_restockTime(restockTime)
    , m_cookCount(CookCount)
{}

///////////////////////////////////////////////////////////////////////////////
Reception::~Reception() {}

///////////////////////////////////////////////////////////////////////////////
void Reception::DisplayStatus(void)
{
    std::cout << "status check: \n";
    int i = 1;

    for (const auto &it : m_kitchens)
    {
        std::cout << "kitchen " << i << ": \n";
        // thing for the cooks.
        // thing for ingredients
        // const auto& stockList = it->m_;
    }
}

///////////////////////////////////////////////////////////////////////////////
void Reception::NewKitchen(void)
{
    m_kitchens.push_back(std::make_unique<Kitchen>(m_cookCount, 1.0, m_restockTime));
}

///////////////////////////////////////////////////////////////////////////////
void Reception::PizzaGate(void)
{

}

///////////////////////////////////////////////////////////////////////////////
void Reception::RemoveKitchen(size_t ID)
{
    m_kitchens.erase(
        std::remove_if(m_kitchens.begin(), m_kitchens.end(),
            [ID](const std::unique_ptr<Kitchen>& kitchen) {
                return kitchen->getId() == ID;
            }),
        m_kitchens.end()
    );
}

} // !namespace Plazza
