///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <string>
#include <vector>
#include <cstdint>
#include <cstring>
#include <variant>
#include <optional>
#include <type_traits>

///////////////////////////////////////////////////////////////////////////////
// Namespace Plazza
///////////////////////////////////////////////////////////////////////////////
namespace Plazza
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
///////////////////////////////////////////////////////////////////////////////
class Message
{
public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Closed
    {
        size_t id;
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Order
    {
        size_t id;
        uint16_t pizza;
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct Status
    {
        size_t id;
        std::string stock;
        int64_t timestamp;
        size_t idleCount;
        size_t pizzaCount;
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct RequestStatus
    {};

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    struct CookedPizza
    {
        size_t id;
        uint16_t pizza;
    };

private:
    ///////////////////////////////////////////////////////////////////////////
    //
    ///////////////////////////////////////////////////////////////////////////
    std::variant<
        Closed,
        Order,
        Status,
        RequestStatus,
        CookedPizza
    > m_data;

private:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Check if a type is one of the variant types
    ///
    /// \tparam T
    /// \tparam Ts
    ///
    /// \return True if the type is one of the variant types
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T, typename... Ts>
    static constexpr bool IsOneOf(const std::variant<Ts...>*)
    {
        return (std::disjunction_v<std::is_same<T, Ts>...>);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Check if a type is a subtype
    ///
    /// \tparam T
    ///
    /// \return True if the type is a subtype
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    static constexpr bool IsSubType = IsOneOf<T>(
        decltype(&m_data)(nullptr)
    );

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    Message(const T& data)
    {
        static_assert(IsSubType<T>, "Invalid type");
        if constexpr (IsSubType<T>)
        {
            m_data = data;
        }
    }

private:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param buffer
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    static void AppendToBuffer(
        std::vector<char>& buffer,
        const T& value
    )
    {
        static_assert(
            std::is_trivial_v<T> && std::is_standard_layout_v<T>,
            "Type must be POD-like for direct memory copy."
        );
        const char* bytes = reinterpret_cast<const char*>(&value);
        buffer.insert(buffer.end(), bytes, bytes + sizeof(T));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param buffer
    /// \param str
    ///
    ///////////////////////////////////////////////////////////////////////////
    static void AppendToBuffer(
        std::vector<char>& buffer,
        const std::string& str
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \param current
    /// \param end
    /// \param value
    ///
    ///////////////////////////////////////////////////////////////////////////
    template<typename T>
    static bool ReadFromBuffer(const char*& current, const char* end, T& value)
    {
        static_assert(
            std::is_trivial_v<T> && std::is_standard_layout_v<T>,
            "Type must be POD-like for direct memory copy."
        );
        if (current + sizeof(T) > end)
        {
            return (false);
        }
        std::memcpy(&value, current, sizeof(T));
        current += sizeof(T);
        return (true);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param current
    /// \param end
    /// \param str
    ///
    ///////////////////////////////////////////////////////////////////////////
    static bool ReadFromBuffer(
        const char*& current,
        const char* end,
        std::string& str
    );

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam T
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    bool Is(void) const
    {
        static_assert(IsSubType<T>, "Invalid type");
        if constexpr (IsSubType<T>)
        {
            return (std::holds_alternative<T>(m_data));
        }
        return (false);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the event as a specific type
    ///
    /// \tparam T
    ///
    /// \return The event as the specified type
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    T* GetIf(void)
    {
        static_assert(IsSubType<T>, "Invalid type");
        if constexpr (IsSubType<T>)
        {
            return (std::get_if<T>(&m_data));
        }
        return (nullptr);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the event as a specific type
    ///
    /// \tparam T
    ///
    /// \return The event as the specified type
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename T>
    const T* GetIf(void) const
    {
        static_assert(IsSubType<T>, "Invalid type");
        if constexpr (IsSubType<T>)
        {
            return (std::get_if<T>(&m_data));
        }
        return (nullptr);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Construct the event as a specific type
    ///
    /// \tparam Visitor
    ///
    /// \param visitor The visitor to construct the event
    ///
    /// \return The constructed event
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename Visitor>
    decltype(auto) Visit(Visitor&& visitor)
    {
        return (std::visit(std::forward<Visitor>(visitor), m_data));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Construct the event as a specific type
    ///
    /// \tparam Visitor
    ///
    /// \param visitor The visitor to construct the event
    ///
    /// \return The constructed event
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename Visitor>
    decltype(auto) Visit(Visitor&& visitor) const
    {
        return (std::visit(std::forward<Visitor>(visitor), m_data));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    std::vector<char> Pack(void) const;

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    static std::optional<Message> Unpack(const std::vector<char>& buffer);
};

} // !namespace Plazza
