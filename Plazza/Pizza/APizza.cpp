///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include "Pizza/APizza.hpp"
#include <stdexcept>
#include <sstream>

///////////////////////////////////////////////////////////////////////////////
// Namespace Plazza
///////////////////////////////////////////////////////////////////////////////
namespace Plazza
{

///////////////////////////////////////////////////////////////////////////////
float APizza::s_cookingTimeMultiplier = 1.0f;

///////////////////////////////////////////////////////////////////////////////
APizza::APizza(
    IPizza::Type type,
    IPizza::Size size,
    float baseCookingTime,
    const std::vector<Ingredient>& ingredients
)
    : m_type(type)
    , m_size(size)
    , m_baseCookingTime(baseCookingTime)
    , m_ingredients(ingredients)
{}

///////////////////////////////////////////////////////////////////////////////
IPizza::Type APizza::GetType(void) const
{
    return (m_type);
}

///////////////////////////////////////////////////////////////////////////////
IPizza::Size APizza::GetSize(void) const
{
    return (m_size);
}

///////////////////////////////////////////////////////////////////////////////
float APizza::GetCookingTime(void) const
{
    return (m_baseCookingTime * s_cookingTimeMultiplier);
}

///////////////////////////////////////////////////////////////////////////////
const std::vector<Ingredient>& APizza::GetIngredients(void) const
{
    return (m_ingredients);
}

///////////////////////////////////////////////////////////////////////////////
void APizza::SetCookingTimeMultiplier(float multiplier)
{
    if (multiplier <= 0.0f)
    {
        throw std::invalid_argument("Cooking time multiplier must be positive");
    }

    s_cookingTimeMultiplier = multiplier;
}

///////////////////////////////////////////////////////////////////////////////
float APizza::GetCookingTimeMultiplier(void)
{
    return (s_cookingTimeMultiplier);
}

///////////////////////////////////////////////////////////////////////////////
IPizza::PackOutCome APizza::Pack(void) const
{
    return {};
}

///////////////////////////////////////////////////////////////////////////////
std::optional<std::unique_ptr<IPizza>> IPizza::Unpack(
    IPizza::PackOutCome packed
)
{
    (void)packed;
    return (std::nullopt);
}

} // !namespace Plazza
