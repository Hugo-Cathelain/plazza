///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include "Concurrency/CondVar.hpp"

///////////////////////////////////////////////////////////////////////////////
// Namespace Plazza
///////////////////////////////////////////////////////////////////////////////
namespace Plazza
{

///////////////////////////////////////////////////////////////////////////////
CondVar::CondVar(void)
    : m_cv()
{}

///////////////////////////////////////////////////////////////////////////////
void CondVar::Wait(IMutex& mutex)
{
    std::unique_lock<std::mutex> lock(mutex);
    m_cv.wait(lock);
}

///////////////////////////////////////////////////////////////////////////////
bool CondVar::DoWaitFor(
    IMutex& mutex,
    const std::chrono::milliseconds& relTime
)
{
    std::unique_lock<std::mutex> lock(mutex);
    return (m_cv.wait_for(lock, relTime) == std::cv_status::no_timeout);
}

///////////////////////////////////////////////////////////////////////////////
bool CondVar::DoWaitFor(
    std::unique_lock<std::mutex>& lock,
    const std::chrono::milliseconds& timeout
)
{
    return (m_cv.wait_for(lock, timeout) == std::cv_status::no_timeout);
}

///////////////////////////////////////////////////////////////////////////////
void CondVar::NotifyOne(void)
{
    m_cv.notify_one();
}

///////////////////////////////////////////////////////////////////////////////
void CondVar::NotifyAll(void)
{
    m_cv.notify_all();
}

///////////////////////////////////////////////////////////////////////////////
std::condition_variable& CondVar::GetNativeHandle(void)
{
    return (m_cv);
}

} // !namespace Plazza
